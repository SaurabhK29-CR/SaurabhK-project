<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GPS Time vs Speed â€” Final Brake Feel & Power Analysis</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body{font-family:Arial, sans-serif;margin:20px;background:#fff;color:#111}
  .controls{text-align:center;margin-bottom:10px}
  input,select,button{margin:4px;padding:6px 10px;font-size:14px}
  button{background:#2b6cb0;color:#fff;border:none;border-radius:6px;cursor:pointer}
  button:hover{background:#1a4f88}
  canvas{width:100%;height:760px}
  .legend-note{text-align:center;margin-top:8px;font-size:14px;font-weight:600}
  table{width:95%;margin:15px auto;border-collapse:collapse;font-size:15px;text-align:center}
  th,td{border:1px solid #000;padding:6px 8px;font-weight:600}
  th{background:#f2f2f2}
  .highlight-irregular{color:red;font-weight:bold;font-size:17px;}
  .highlight-alert{color:darkorange;font-weight:bold;}
  .irregular-note{width:90%;margin:15px auto;border:2px solid red;padding:10px;background:#fff5f5;color:#b00000;font-weight:bold;font-size:15px;border-radius:8px;}
  .page-break{page-break-before:always}
  @page{size:A4 landscape;margin:12mm 8mm 12mm 8mm}
  @media print{
    .controls{display:none}
    .legend-note{font-size:13px;margin-top:0}
    canvas{height:650px!important;margin-top:0}
    .page-break{page-break-before:always}
    table{width:100%;font-size:13px}
  }
</style>
</head>
<body>
<div class="controls">
  <input type="file" id="csvFile" accept=".csv" /><br>
  <input type="text" id="driverName" placeholder="Driver Name" />
  <input type="text" id="trainNo" placeholder="Train No" />
  <input type="text" id="section" placeholder="Section" />
  <input type="text" id="analysedBy" placeholder="Analysed By" /><br>
  <label>Train Date : </label>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
  <input type="date" id="runDate" /><br>
  <label>SPM analysis Date : </label>
  <input type="date" id="analysedOn" /><br>

  <label><b>Start Station:</b></label>
  <select id="startStation"><option value="">--Select--</option></select>
  <label><b>End Station:</b></label>
  <select id="endStation"><option value="">--Select--</option></select>

  <button id="plotGraph">Plot Graph</button>
  <button onclick="window.print()">ðŸ–¨ Print</button>
</div>

<canvas id="speedChart"></canvas>
<div class="legend-note">
  â–² 1000 mâ€ƒÎ£ 110 mâ€ƒ(red = triangle, green = sigma)
</div>
<div id="speedTableContainer" class="page-break"></div>

<script>
let allData = [], currentChart = null;

// ====== CSV Import + Dropdown Population ======
document.getElementById("csvFile").addEventListener("change", (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const r = new FileReader();
  r.onload = (evt) => {
    const lines = evt.target.result.split(/\r?\n/).filter((l) => l.trim() !== "");
    const h = lines[0].split(",").map((v) => v.trim().toLowerCase());

    const g = h.findIndex((v) => v.includes("gps time"));
    const s = h.findIndex((v) => v === "speed");
    const st = h.findIndex((v) => v.includes("stationcode"));
    const d = h.findIndex((v) => v.includes("distfromprev"));

    if (g === -1 || s === -1 || st === -1 || d === -1)
      return alert("CSV must include Gps Time, Speed, StationCode, distFromPrevLatLng");

    allData = lines.slice(1).map((l) => {
      const c = l.split(",");
      return {
        gps: (c[g] || "").trim(),
        spd: parseFloat((c[s] || "").trim()),
        st: (c[st] || "").trim(),
        dist: parseFloat((c[d] || "0").trim()) || 0,
      };
    }).filter((x) => x.gps && !isNaN(x.spd));

    const stationSet = new Set(allData.map((x) => x.st).filter(Boolean));
    const stations = [...stationSet];
    const startSel = document.getElementById("startStation");
    const endSel = document.getElementById("endStation");
    startSel.innerHTML = '<option value="">--Select--</option>';
    endSel.innerHTML = '<option value="">--Select--</option>';
    stations.forEach((st) => {
      const opt1 = document.createElement("option");
      opt1.value = st; opt1.textContent = st;
      const opt2 = opt1.cloneNode(true);
      startSel.appendChild(opt1);
      endSel.appendChild(opt2);
    });

    alert("CSV loaded and station dropdowns populated. Now select start and end stations, then click Plot Graph.");
  };
  r.readAsText(f);
});

function findZeroIndex(d, code, from) {
  for (let i = from; i < d.length; i++)
    if (d[i].st === code && d[i].spd === 0) return i;
  return -1;
}

function calculateDuration(startStr, endStr) {
  startStr = startStr.trim();
  endStr = endStr.trim();

  const startParts = startStr.split(" ");
  const endParts = endStr.split(" ");

  const startTime = startParts.length > 1 ? startParts[1] : startParts[0];
  const endTime = endParts.length > 1 ? endParts[1] : endParts[0];

  const normalize = (t) => {
    const bits = t.split(":");
    if (bits.length === 2) bits.push("00");
    return bits.map(b => b.padStart(2, "0")).join(":");
  };

  const toSeconds = (t) => {
    const [h, m, s] = t.split(":").map(Number);
    return h * 3600 + m * 60 + s;
  };

  let diff = toSeconds(endTime) - toSeconds(startTime);
  if (diff < 0) diff += 24 * 3600;

  const hrs = Math.floor(diff / 3600);
  const mins = Math.floor((diff % 3600) / 60);
  const secs = diff % 60;

  return { totalSeconds: diff, formatted: `${hrs}h ${mins}m ${secs}s` };
}

// ====== Main Plot Graph Logic ======
document.getElementById("plotGraph").addEventListener("click", () => {
  if (allData.length === 0) return alert("Please load a CSV file first.");
  const start = document.getElementById("startStation").value.trim().toUpperCase();
  const end = document.getElementById("endStation").value.trim().toUpperCase();
  const driver = document.getElementById("driverName").value.trim();
  const train = document.getElementById("trainNo").value.trim();
  const section = document.getElementById("section").value.trim();
  const runDate = document.getElementById("runDate").value;
  const analysedBy = document.getElementById("analysedBy").value.trim();
  const analysedOn = document.getElementById("analysedOn").value;

  const startIdx = allData.findIndex((d) => d.st === start);
  const endIdx = allData.findIndex((d, i) => i > startIdx && d.st === end);
  if (startIdx === -1 || endIdx === -1) return alert("Stations not found or invalid order.");
  const sZero = findZeroIndex(allData, start, startIdx);
  const eZero = findZeroIndex(allData, end, endIdx);
  if (sZero === -1 || eZero === -1) return alert("Could not find stop points for given stations.");

  let endRise = -1;
  for (let i = eZero + 1; i < allData.length; i++) {
    if (allData[i].spd >= 0.4) { endRise = i; break; }
  }
  if (endRise === -1) return alert("No speed rise detected after end station.");

  const seg = allData.slice(sZero, endRise + 1);

  // Format date as dd-mm-yyyy
  function formatDate(dateStr) {
    if (!dateStr) return "-";
    const dateObj = new Date(dateStr);
    if (isNaN(dateObj)) return "-";
    const dd = String(dateObj.getDate()).padStart(2, '0');
    const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
    const yyyy = dateObj.getFullYear();
    return `${dd}-${mm}-${yyyy}`;
  }

  // Format datetime as dd-mm-yyyy HH:MM
  function formatDateTime(dateTimeStr) {
    if (!dateTimeStr) return "-";
    const [datePart, timePart] = dateTimeStr.split(" ");
    if (!datePart || !timePart) return dateTimeStr;
    
    const formattedDate = formatDate(datePart);
    const timeBits = timePart.split(":");
    const formattedTime = `${timeBits[0]}:${timeBits[1] || '00'}`;
    
    return `${formattedDate} ${formattedTime}`;
  }

  // Generate labels with date in dd-mm-yyyy format
  let secondCounter = 0, prevTime = "", prevDate = "";
  const labels = seg.map(x => {
    const [datePart, timePart] = x.gps.split(" ");
    const showDate = (datePart !== prevDate);
    if (x.gps === prevTime) secondCounter++;
    else { secondCounter = 0; prevTime = x.gps; }
    prevDate = datePart;
    const displayDate = showDate ? formatDate(datePart) : "";
    const displayTime = timePart + (secondCounter > 0 ? ":" + String(secondCounter).padStart(2, "0") : "");
    return showDate ? `${displayDate} ${displayTime}` : displayTime;
  });

  const speeds = seg.map(x => x.spd), dists = seg.map(x => x.dist);

  const firstIdx = {}; for (let i = 0; i < seg.length; i++) { const s = seg[i].st; if (s && !firstIdx[s]) firstIdx[s] = i; }
  const stations = Object.keys(firstIdx).map(s => ({ st: s, index: firstIdx[s], stop: seg[firstIdx[s]].spd === 0 }));

  function detectBrake(seg, min, max, start) {
    const tol = 0.3, dropPct = 48;
    for (let i = 0; i < seg.length - 1; i++) {
      if (seg[i].st !== start) break;
      const s = seg[i].spd, n = seg[i + 1].spd;
      if (s >= min && s <= max && n < s - tol) {
        let minV = n, minIdx = i + 1;
        for (let k = i + 1; k < seg.length - 1; k++) {
          if (seg[k].st !== start) break;
          if (seg[k].spd < minV) { minV = seg[k].spd; minIdx = k; }
          if (seg[k + 1].spd > seg[k].spd + tol) break;
        }
        const drop = ((s - minV) / s) * 100;
        if (drop >= dropPct)
          return { text: `PASS (â†“${s.toFixed(1)}â†’${minV.toFixed(1)} km/h, ${drop.toFixed(1)}%)`, startIndex: i, endIndex: minIdx, startVal: s, minVal: minV };
      }
    }
    return { text: "FAIL (no event)", startIndex: -1, endIndex: -1 };
  }

  const feel = detectBrake(seg, 12, 20, start);
  const power = detectBrake(seg, 65, 85, start);

  const stopStations = [], seen = new Set();
  for (let i = 0; i < seg.length; i++) {
    if (seg[i].spd === 0 && seg[i].st && !seen.has(seg[i].st)) {
      seen.add(seg[i].st);
      const stopTime = seg[i].gps;
      let startTime = "-";
      for (let j = i + 1; j < seg.length; j++) { if (seg[j].spd > 0) { startTime = seg[j].gps; break; } }
      stopStations.push({ index: i, station: seg[i].st, stopTime, startTime });
    }
  }

  const distCheck = [1000, 750, 500, 110, 20];
  const irregularities = [];
  const speedBeforeStops = stopStations.map(stop => {
    let res = { station: stop.station, stopTime: stop.stopTime, startTime: stop.startTime };
    let cum = 0, found = {}, foundIdx = {};
    for (let i = stop.index; i >= 0; i--) {
      cum += dists[i] || 0;
      for (const d of distCheck) {
        if (!found[d] && cum >= d) { found[d] = seg[i].spd; foundIdx[d] = i; }
      }
    }
    distCheck.forEach(d => { res[`s${d}`] = found[d] ?? "-"; res[`idx${d}`] = foundIdx[d] ?? -1; });
    if (res.s1000 > 50) irregularities.push(`Station ${res.station}: Speed @1000 m = ${res.s1000} km/h (should be â‰¤ 50)`);
    if (res.s20 >= 10) irregularities.push(`Station ${res.station}: Speed @20 m = ${res.s20} km/h (should be â‰¤ 10)`);
    return res;
  });

  const startTimeStr = formatDateTime(seg[0].gps);
  const endTimeStr = formatDateTime(seg[seg.length - 1].gps);
  const dur = calculateDuration(seg[0].gps, seg[seg.length - 1].gps);
  const totalDuration = dur.formatted;

  const maxSpd = Math.max(...seg.map(d => d.spd));
  const maxTime = seg.find(d => d.spd === maxSpd)?.gps || "-";
  
  // Calculate Average Speed
  const avgSpd = speeds.reduce((sum, speed) => sum + speed, 0) / speeds.length;

  // Generate HTML Summary
  const summary = `<table style="width:70%;margin:auto;">
<tr><th colspan="2">Performance Analysis Summary</th></tr>
<tr><td><b>Driver Name</b></td><td>${driver || "-"}</td></tr>
<tr><td><b>Train No</b></td><td>${train || "-"}</td></tr>
<tr><td><b>Section</b></td><td>${section || "-"}</td></tr>
<tr><td><b>Date</b></td><td>${formatDate(runDate) || "-"}</td></tr>
<tr><td><b>Start Time</b></td><td>${startTimeStr}</td></tr>
<tr><td><b>End Time</b></td><td>${endTimeStr}</td></tr>
<tr><td><b>Total Duration</b></td><td>${totalDuration}</td></tr>
<tr><td><b>Analyzed By</b></td><td>${analysedBy || "-"}</td></tr>
<tr><td><b>Analyzed On</b></td><td>${formatDate(analysedOn) || "-"}</td></tr>
<tr><td><b>Maximum Speed</b></td><td>${maxSpd.toFixed(1)} km/h at ${formatDateTime(maxTime)}</td></tr>
<tr><td><b>Average Speed</b></td><td>${avgSpd.toFixed(1)} km/h</td></tr>
<tr><td><b>Brake Feel Test (12â€“20 km/h)</b></td><td>${feel.text}</td></tr>
<tr><td><b>Brake Power Test (65â€“85 km/h)</b></td><td>${power.text}</td></tr></table>`;

  const dataTableRows = speedBeforeStops.map(r => {
    const cells = distCheck.map(d => {
      const val = r["s" + d];
      if (val === "-") return `<td>-</td>`;
      if (d === 1000 && val > 50) return `<td class='highlight-irregular'>${val}</td>`;
      if (d === 20 && val >= 10) return `<td class='highlight-alert'>${val}</td>`;
      return `<td>${val}</td>`;
    }).join("");
    return `<tr><td>${r.station}</td><td>${formatDateTime(r.stopTime)}</td><td>${formatDateTime(r.startTime)}</td>${cells}</tr>`;
  }).join("");

  const dataTable = `<table>
<tr><th>Station</th><th>Stop Time</th><th>Start Time</th>${distCheck.map(d => `<th>Speed @${d} m</th>`).join("")}</tr>${dataTableRows}</table>`;

  let irregularityNote = "";
  if (irregularities.length > 0) {
    irregularityNote = `<div class="irregular-note">âš  <u>Irregularities Detected:</u><br>${irregularities.map(x => "â€¢ " + x).join("<br>")}</div>`;
  }

  document.getElementById("speedTableContainer").innerHTML = summary + "<br>" + dataTable + irregularityNote;

  const fS = new Array(speeds.length).fill(null), fE = new Array(speeds.length).fill(null),
    pS = new Array(speeds.length).fill(null), pE = new Array(speeds.length).fill(null);
  if (feel.startIndex !== -1) { fS[feel.startIndex] = feel.startVal; fE[feel.endIndex] = feel.minVal; }
  if (power.startIndex !== -1) { pS[power.startIndex] = power.startVal; pE[power.endIndex] = power.minVal; }

  function speedColor(s) {
    if (s <= 20) return "gray";
    if (s <= 40) return "blue";
    if (s <= 110) return "green";
    if (s <= 130) return "orange";
    return "red";
  }

  const multiColorLine = {
    id: "multiColor",
    afterDatasetsDraw(chart) {
      const ctx = chart.ctx, m = chart.getDatasetMeta(0), d = m.data;
      if (!d || d.length < 2) return;
      ctx.save();
      ctx.lineWidth = 2;
      for (let i = 1; i < d.length; i++) {
        const p = d[i - 1], c = d[i];
        ctx.beginPath();
        ctx.strokeStyle = speedColor(chart.data.datasets[0].data[i]);
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(c.x, c.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  };

  const stationLines = {
    id: "stationLines",
    afterDatasetsDraw(chart) {
      const ctx = chart.ctx, m = chart.getDatasetMeta(0), bottom = chart.chartArea.bottom;
      ctx.save();
      ctx.font = "bold 10px Arial";
      ctx.textAlign = "center";

      // Show ALL stations without filtering
      stations.forEach((s, i) => {
        const pt = m.data[s.index];
        if (!pt) return;
        
        // Draw vertical line
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = s.stop ? "red" : "gray";
        ctx.beginPath();
        ctx.moveTo(pt.x, chart.chartArea.top);
        ctx.lineTo(pt.x, bottom);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw station label with rotated text to save space
        ctx.fillStyle = s.stop ? "red" : "black";
        ctx.textBaseline = "top";
        
        // Rotate text 45 degrees to fit more labels
        ctx.save();
        ctx.translate(pt.x, bottom + 15);
        ctx.rotate(-Math.PI / 2); // -45 degrees
        ctx.fillText(s.st, 0, 0);
        ctx.restore();
      });
      
      ctx.restore();
    }
  };

  const distanceMarkers = {
    id: "distanceMarkers",
    afterDatasetsDraw(chart) {
      const ctx = chart.ctx, m = chart.getDatasetMeta(0);
      if (!m || !m.data) return;
      ctx.save();
      speedBeforeStops.forEach(r => {
        [1000, 110].forEach(d => {
          const idx = r[`idx${d}`];
          if (idx >= 0 && idx < seg.length) {
            const pt = m.data[idx];
            if (!pt) return;
            if (d === 1000) {
              ctx.fillStyle = "blue";
              ctx.beginPath();
              ctx.moveTo(pt.x, pt.y - 6);
              ctx.lineTo(pt.x - 5, pt.y + 5);
              ctx.lineTo(pt.x + 5, pt.y + 5);
              ctx.closePath();
              ctx.fill();
            }
            if (d === 110) {
              ctx.fillStyle = "green";
              ctx.font = "bold 18px Arial";
              ctx.fillText("Î£", pt.x - 5, pt.y + 6);
            }
          }
        });
      });
      ctx.restore();
    }
  };

  const analysisText = {
    id: "analysisText",
    afterDraw(chart) {
      const ctx = chart.ctx;
      ctx.save();
      ctx.font = "bold 14px Arial";
      ctx.fillStyle = "black";
      ctx.fillText(`Train ${train || ""} ${section || ""}`, chart.chartArea.left + 10, chart.chartArea.top - 10);
      ctx.restore();
    }
  };

  const ctx = document.getElementById("speedChart").getContext("2d");
  if (currentChart) currentChart.destroy();
  currentChart = new Chart(ctx, {
    type: "line",
    data: {
      labels: labels,
      datasets: [
        { label: "Speed", data: speeds, borderColor: "#999", borderWidth: 1.5, pointRadius: 0 },
        { data: fS, borderColor: "red", showLine: false, pointRadius: 6, pointStyle: "circle" },
        { data: fE, borderColor: "green", showLine: false, pointRadius: 6, pointStyle: "triangle" },
        { data: pS, borderColor: "blue", showLine: false, pointRadius: 6, pointStyle: "circle" },
        { data: pE, borderColor: "purple", showLine: false, pointRadius: 6, pointStyle: "triangle" }
      ]
    },
    options: {
      responsive: true,
      animation: false,
      layout: { padding: { top: 40, bottom: 80 } },
      scales: {
        x: {
          title: { display: true, text: "Time (HH:MM:SS)" },
          ticks: {
            callback: (v, index, ticks) => {
              return labels[index] || "";
            },
            maxTicksLimit: 50,
            autoSkip: true,
            autoSkipPadding: 10,
            maxRotation: 90,
            minRotation: 45
          }
        },
        y: { title: { display: true, text: "Speed (km/h)" }, min: 0 }
      },
      plugins: { legend: { display: false } }
    },
    plugins: [multiColorLine, stationLines, distanceMarkers, analysisText]
  });
});
</script>
</body>
</html>